// Generated by CoffeeScript 1.12.4
var Event, SortedArray, Type, chokidar, errors, path, type;

SortedArray = require("SortedArray");

chokidar = require("chokidar");

Event = require("eve");

Type = require("Type");

path = require("path");

type = Type("ModuleWatcher");

type.defineArgs(function() {
  return {
    required: [true, false],
    types: [
      String.or(Array), {
        ignored: String.or(Array).Maybe
      }
    ]
  };
});

type.defineGetters({
  isLoading: function() {
    return this._isLoading;
  }
});

type.defineMethods({
  close: function() {
    this._watcher.close();
  },
  on: function(event, callback) {
    return this._events.on(event, callback);
  },
  once: function(event, callback) {
    return this._events.once(event, callback);
  }
});

type.defineValues(function(root, options) {
  return {
    _isLoading: true,
    _root: root,
    _modules: SortedArray([], this._moduleSorter),
    _modulePaths: new Set,
    _watcher: this._watch(root, options),
    _events: Event.Map()
  };
});

type.defineBoundMethods({
  _onChange: function(event, modPath) {
    if (modPath === this._root) {
      return;
    }
    if (this._isLoading) {
      if (event === "addDir") {
        this._modulePaths.add(modPath);
      } else if (event === "unlinkDir") {
        this._modulePaths["delete"](modPath);
      }
      return;
    }
    if (event === "addDir") {
      this._addModule(modPath);
    } else if (event === "unlinkDir") {
      this._removeModule(modPath);
    }
  }
});

type.definePrototype({
  _moduleSorter: function(a, b) {
    a = a.name.toLowerCase();
    b = b.name.toLowerCase();
    if (a > b) {
      return 1;
    } else {
      return -1;
    }
  }
});

type.defineMethods({
  _watch: function(root, options) {
    var watcher;
    if (options == null) {
      options = {};
    }
    options.depth = 0;
    watcher = chokidar.watch(root, options);
    watcher.on("all", this._onChange);
    watcher.once("ready", (function(_this) {
      return function() {
        _this._isLoading = false;
        _this._modulePaths.forEach(function(modPath) {
          var mod;
          if (mod = _this._loadModule(modPath)) {
            return _this._modules.insert(mod);
          }
        });
        return _this._events.emit("ready", _this._modules.array);
      };
    })(this));
    return watcher;
  },
  _addModule: function(modPath) {
    var mod, modName;
    modName = path.basename(modPath);
    if (lotus.modules.has(modName)) {
      return;
    }
    if (!(mod = this._loadModule(modPath))) {
      return;
    }
    this._modulePaths.add(modPath);
    return this._events.emit("add", mod);
  },
  _removeModule: function(modPath) {
    var mod, modName;
    modName = path.basename(modPath);
    if (!lotus.modules.has(modName)) {
      return;
    }
    mod = lotus.modules["delete"](modName);
    return this._events.emit("unlink", mod);
  },
  _loadModule: function(modPath) {
    var error, mod;
    try {
      mod = lotus.modules.load(modPath);
    } catch (error1) {
      error = error1;
      errors.loadModule(error);
      return null;
    }
    if (mod && !lotus.isModuleIgnored(mod.name)) {
      return mod;
    } else {
      return null;
    }
  }
});

module.exports = type.build();

errors = {};

errors.loadModule = function(error) {
  var message;
  message = error.message;
  if (message.startsWith("Module path must be a directory:")) {
    return;
  }
  if (message.startsWith("Missing config file:")) {
    return;
  }
  throw error;
};
